#include<bits/stdc++.h>

using namespace std;

///////////////////////////////////////////////////////////////////////////////////
// 概要
///////////////////////////////////////////////////////////////////////////////////

// LCA(Doubling ver)
// 木に対して高速なクエリ応答が可能(例えば、ある２つの頂点間のパスで最も辺の重さが重いものを返したり...)
// 木の頂点数をNとする
// -構築にO(NlogN)
// -クエリ応答にO(logN)
// LCAを求めるための大まかな流れ
// 1.
// dfsをして、
// -各ノードの親ノード(いなければ-1)
// -各ノードの深さ
// -クエリで必要な情報
// の3つを記録しておく
// 2.
// Doublingをして
// -あるノードから2^iだけ上にあるノード番号(いなければ-1)
// -あるノードから2^iだけ上にあるノードまでのパスの何かしらの情報(いなければ影響を与えないような値)
// の2つを記録する
// (1,2までが準備)
// 3.
// ある2つのノードa, bに対するLCAを求めつつ、クエリ応答に必要な情報も同様に求めていく
// まず、a, bの深さが異なるならば、同じ深さにする(a, bの浅い方に合わせてあげる)
// この時点で、a, bが同じノードならば、ここで終わる
// あとは、a, bの親ノードが一致する場所までa, bを二分探索で引き上げる.
// (注意:最終的に求まったa, bはa, bの親が一致する最も深いノードなのでa == bとは限らない)

///////////////////////////////////////////////////////////////////////////////////
// VARIABLE
///////////////////////////////////////////////////////////////////////////////////

const int N = 100001;  // ありうる最大の頂点数
int n;                 // 入力のノードの数
vector <pair <int, int> > v[N];
                       // グラフ情報
int par[N][20];        // par[i][j] := ノードiの2^j上にあるノード(par[i][0]はiの親ノードの番号を入れる)
int depth[N];          // depth[i] := ノードiの深さ
bool visit[N];         // dfsした際の、既訪問フラグ
int MaxCost[N][20];    // クエリ応答に必要な情報 MaxCost[i][j] := ノードiの2^i上にあるノードまでのパス
                       // の中での最大の辺のコスト

///////////////////////////////////////////////////////////////////////////////////
// TEMPLATE
///////////////////////////////////////////////////////////////////////////////////

// /*...*/ で囲った場所は、クエリ特有の操作をするところなので、問題におおじて適宜変更してください.
// 基本的には、/*...*/ のところに書いてあげると正しく動作すると思います.

void dfs(int now, int p, int d, /*int cost*/) {
  visit[now] = true;
  par[now][0] = p;
  /*MaxCost[now][0] = cost;*/
  depth[now] = d;
  rep(i, 0, (int) v[now].size()) {
    if (!visit[v[now][i].fi]) dfs(v[now][i].fi, now, d + 1, /*v[now][i].se*/);
  }
}

void SetTable() {
  rep(i, 0, 19) {
    rep(j, 0, n) {
      if (par[j][i] == -1) par[j][i + 1] = -1;
      else par[j][i + 1] = par[par[j][i]][i];
      /*if (MaxCost[j][i] == -1) MaxCost[j][i + 1] = -1;
      else MaxCost[j][i + 1] = max(MaxCost[j][i], MaxCost[par[j][i]][i]);*/
    }
  }
}

int lca(int a, int b) {
  if (depth[a] < depth[b]) swap(a, b);
  int res = /*-1*/;
  rep(i, 0, 20) {
    if ((depth[a] - depth[b]) & (1LL << i)) {
      /*chmax(res, MaxCost[a][i]);*/
      a = par[a][i];
    }
  }
  if (a == b) return res;
  rrep(i, 19, -1) {
    if (par[a][i] != par[b][i]) {
      /*chmax(res, MaxCost[a][i]);*/
      /*chmax(res, MaxCost[b][i]);*/
      a = par[a][i];
      b = par[b][i];
    }
  }
  /*chmax(res, MaxCost[a][0]);*/
  /*chmax(res, MaxCost[b][0]);*/
  return res;
}

///////////////////////////////////////////////////////////////////////////////////
// MAIN 以下の順番で使ってね.
///////////////////////////////////////////////////////////////////////////////////

int main() {
	dfs();
	SetTable(); // 構築段階ではO(NlogN)かかる.
	
	lca(a, b); // クエリに対する応答はO(logN)かかる.
}
